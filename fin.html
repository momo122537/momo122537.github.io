<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>1132915-FinalTerm</title>
  <style>
    body{
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg,#2c3e50,#34495e);
      display:flex; justify-content:center; align-items:center;
      min-height:100vh; margin:0; color:#ecf0f1;
    }
    .game-container{
      text-align:center;
      background: rgba(0,0,0,0.82);
      padding: 26px;
      border-radius: 20px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
      width:min(92vw, 820px);
    }
    h1{
      font-size:2.2em;
      background: linear-gradient(45deg,#f39c12,#e67e22);
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      margin: 10px 0 6px;
    }
    .status{
      font-size:1.05em;
      margin: 14px 0;
      padding: 12px 14px;
      background: rgba(52,73,94,0.75);
      border-radius: 12px;
      border: 2px solid #3498db;
      line-height: 1.55;
    }
    .board-wrap{ display:flex; justify-content:center; margin: 16px auto 10px; }
    canvas{
      background: radial-gradient(circle at 40% 35%, #a8733a 0%, #7a4b21 60%, #5b3618 100%);
      border-radius: 16px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.5);
      touch-action: none;
    }
    .controls{ margin-top: 10px; display:flex; flex-wrap:wrap; gap:8px; justify-content:center; align-items:center; }
    button, select{
      border:none;
      padding: 11px 16px;
      border-radius: 999px;
      font-size: 15px;
    }
    button{
      background: linear-gradient(45deg,#3498db,#2980b9);
      color:#fff; cursor:pointer;
      transition: all .25s ease;
    }
    button:hover:not(:disabled){
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(52,152,219,0.55);
    }
    button:disabled{ background:#95a5a6; cursor:not-allowed; }
    .pass-btn{
      background: linear-gradient(45deg,#f39c12,#e67e22) !important;
      font-weight: 700;
    }
    .pass-btn:hover:not(:disabled){
      box-shadow: 0 8px 25px rgba(243,156,18,0.55) !important;
    }
    .ghost-btn{
      background: linear-gradient(45deg,#9b59b6,#8e44ad) !important;
      font-weight: 700;
    }
    select{
      background: rgba(255,255,255,0.14);
      color:#ecf0f1;
      border: 2px solid rgba(255,255,255,0.25);
      outline:none;
    }
    option{ color:#111; }

    .score{
      display:flex;
      justify-content:space-around;
      margin-top: 12px;
      font-size: 1.12em;
      font-weight: 700;
      gap: 10px;
      flex-wrap: wrap;
    }
    .score div{
      padding: 10px 16px;
      border-radius: 12px;
      min-width: 280px;
    }
    .black-score{ background: rgba(0,0,0,0.65); border: 2px solid #333; }
    .white-score{ background: rgba(255,255,255,0.16); border: 2px solid rgba(255,255,255,0.45); }

    .mini{ opacity:0.92; font-size:0.92em; font-weight:600; margin-top:6px; }

    #passInfo{
      font-size: 0.98em; color:#f1c40f; font-weight:700;
      margin-top: 10px; padding: 8px 10px;
      background: rgba(0,0,0,0.45);
      border-radius: 12px;
      display:inline-block;
    }
    .game-over{
      background: rgba(231,76,60,0.92) !important;
      border-color:#c0392b !important;
      animation: flash 1s infinite;
      font-size: 1.08em;
    }
    @keyframes flash{ 0%,100%{opacity:1;} 50%{opacity:.72;} }
    .no-move{
      background: rgba(243,156,18,0.75) !important;
      border-color:#f39c12 !important;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <h1>ğŸ¯ ä¹è·¯åœæ£‹</h1>
    <div class="status" id="status">ğŸ–¤ é»‘æ£‹å…ˆæ‰‹ï¼šé»äº¤å‰é»ä¸‹å­</div>

    <div class="board-wrap">
      <canvas id="goboard" width="560" height="560" aria-label="9x9 go board"></canvas>
    </div>

    <div class="controls">
      <select id="handicapSel" title="è®“å­æ•¸ï¼ˆå…ˆæ“ºé»‘å­ï¼Œç™½å…ˆï¼‰">
        <option value="0" selected>è®“å­ï¼š0ï¼ˆåˆ†å…ˆï¼‰</option>
        <option value="2">è®“å­ï¼š2ï¼ˆç™½å…ˆï¼‰</option>
        <option value="3">è®“å­ï¼š3ï¼ˆç™½å…ˆï¼‰</option>
        <option value="4">è®“å­ï¼š4ï¼ˆç™½å…ˆï¼‰</option>
        <option value="5">è®“å­ï¼š5ï¼ˆç™½å…ˆï¼‰</option>
      </select>

      <button id="undoBtn">æ‚”æ£‹</button>
      <button id="newBtn">æ–°å±€</button>
      <button class="pass-btn" id="passBtn">è™›æ‰‹(åœä¸€æ‰‹)</button>
      <button class="ghost-btn" id="overlayBtn">æ´»æ£‹/åœ°ç›¤ é¡¯ç¤ºï¼šé—œ</button>
    </div>

    <div class="score">
      <div class="black-score">
        é»‘ï¼ˆæ•¸å­æ³•ï¼‰: <span id="blackScore">0</span>
        <div class="mini">
          æ£‹å­ï¼š<span id="blackStones">0</span>ï½œåœ°ï¼š<span id="blackTerr">0</span>ï½œ
          æå­ï¼š<span id="blackCaps">0</span>
        </div>
      </div>
      <div class="white-score">
        ç™½ï¼ˆæ•¸å­æ³• + è²¼ç›®3.75ï¼‰: <span id="whiteScore">0</span>
        <div class="mini">
          æ£‹å­ï¼š<span id="whiteStones">0</span>ï½œåœ°ï¼š<span id="whiteTerr">0</span>ï½œ
          è²¼ç›®ï¼š<span id="komi">3.75</span>ï½œæå­ï¼š<span id="whiteCaps">0</span>
        </div>
      </div>
    </div>

    <div id="passInfo">é€£çºŒè™›æ‰‹: <span id="passCount">0</span>/2</div>
  </div>

<script>
class NineBoardGo {
  constructor(){
    this.N = 9;
    this.board = this.makeEmpty();
    this.currentPlayer = 1; // 1 black(user), -1 white(AI)
    this.consecutivePasses = 0;
    this.aiEnabled = true; // æ°¸é ä½  vs é›»è…¦
    this.gameOver = false;

    this.komi = 3.75;

    // âœ… é˜²å¹½éˆï¼šæ§åˆ¶ loop / listener / timers
    this.destroyed = false;
    this.rafId = null;
    this.timerIds = [];
    this.canvasClickHandler = (e) => this.onCanvasClick(e);

    this.captures = { black: 0, white: 0 };
    this.prevBoardHash = this.hashBoard(this.board);
    this.history = [];
    this.lastMove = null;

    this.showOverlay = false;
    this.atariHighlights = [];
    this.captureAnims = [];

    this.canvas = document.getElementById("goboard");
    this.ctx = this.canvas.getContext("2d");
    this.padding = 46;
    this.cell = (this.canvas.width - this.padding*2) / (this.N - 1);

    this.starPoints = [{r:2,c:2},{r:2,c:6},{r:6,c:2},{r:6,c:6},{r:4,c:4}];

    this.bindUI();
    this.applyHandicapFromUI();
    this.draw();
    this.updateStatus();
    this.updateScorePreview();
    this.startAnimLoop();
  }

  // âœ… çµ±ä¸€è¨»å†Š timeoutï¼Œdestroy() æœƒå…¨éƒ¨æ¸…æ‰
  setTimer(fn, ms){
    const id = setTimeout(() => {
      if (this.destroyed) return;
      fn();
    }, ms);
    this.timerIds.push(id);
    return id;
  }

  // âœ… æ–°å±€å‰æœƒå‘¼å«ï¼Œå¾¹åº•åœæ‰ä¸Šä¸€å±€ä¸€åˆ‡æ´»å‹•
  destroy(){
    this.destroyed = true;

    if (this.rafId !== null) cancelAnimationFrame(this.rafId);

    for (const id of this.timerIds) clearTimeout(id);
    this.timerIds = [];

    if (this.canvas && this.canvasClickHandler){
      this.canvas.removeEventListener("click", this.canvasClickHandler);
    }

    if (this.ctx && this.canvas){
      this.ctx.clearRect(0,0,this.canvas.width,this.canvas.height);
    }
  }

  // ---------- basics ----------
  makeEmpty(){ return Array(this.N).fill(0).map(()=>Array(this.N).fill(0)); }
  cloneBoard(b){ return b.map(row=>row.slice()); }
  inBounds(r,c){ return r>=0 && r<this.N && c>=0 && c<this.N; }
  neighbors4(r,c){ return [[r-1,c],[r+1,c],[r,c-1],[r,c+1]].filter(([rr,cc])=>this.inBounds(rr,cc)); }
  neighbors8(r,c){
    const ds=[-1,0,1], out=[];
    for(const dr of ds) for(const dc of ds){
      if(dr===0 && dc===0) continue;
      out.push([r+dr,c+dc]);
    }
    return out.filter(([rr,cc])=>this.inBounds(rr,cc));
  }
  rcToXY(r,c){ return { x: this.padding + c*this.cell, y: this.padding + r*this.cell }; }
  hashBoard(b){ return b.map(row=>row.join(",")).join(";"); }

  bindUI(){
    this.canvas.addEventListener("click", this.canvasClickHandler);
    document.getElementById("undoBtn").onclick = ()=>this.undo();
    document.getElementById("newBtn").onclick = ()=>newGame();
    document.getElementById("passBtn").onclick = ()=>this.pass();
    document.getElementById("handicapSel").onchange = ()=> newGame();
    document.getElementById("overlayBtn").onclick = ()=>this.toggleOverlay();
    document.getElementById("komi").textContent = String(this.komi);
  }

  toggleOverlay(){
    if(this.destroyed) return;
    this.showOverlay = !this.showOverlay;
    document.getElementById("overlayBtn").textContent = `æ´»æ£‹/åœ°ç›¤ é¡¯ç¤ºï¼š${this.showOverlay ? "é–‹" : "é—œ"}`;
    this.draw();
  }

  setStatus(html, cls="status"){
    const el = document.getElementById("status");
    el.className = cls;
    el.innerHTML = html;
  }

  pickIntersection(e){
    const rect = this.canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const rFloat = (y - this.padding) / this.cell;
    const cFloat = (x - this.padding) / this.cell;

    const r = Math.round(rFloat);
    const c = Math.round(cFloat);
    if(r < 0 || r >= this.N || c < 0 || c >= this.N) return {r:null,c:null};

    const ix = this.padding + c*this.cell;
    const iy = this.padding + r*this.cell;
    const dist = Math.hypot(ix-x, iy-y);
    if(dist > this.cell*0.42) return {r:null,c:null};

    return {r,c};
  }

  // ---------- groups / liberties ----------
  getGroup(board, r, c){
    const color = board[r][c];
    if(color===0) return {stones:[], libs:new Set()};
    const stack = [[r,c]];
    const seen = Array(this.N).fill(0).map(()=>Array(this.N).fill(false));
    const stones = [];
    const libs = new Set();

    seen[r][c]=true;
    while(stack.length){
      const [cr,cc] = stack.pop();
      stones.push([cr,cc]);
      for(const [nr,nc] of this.neighbors4(cr,cc)){
        if(board[nr][nc]===0) libs.add(nr+"_"+nc);
        else if(board[nr][nc]===color && !seen[nr][nc]){
          seen[nr][nc]=true; stack.push([nr,nc]);
        }
      }
    }
    return {stones, libs};
  }

  removeStones(board, stones){
    for(const [r,c] of stones) board[r][c]=0;
  }

  // ---------- capture + legality ----------
  applyMoveSim(board, r, c, player){
    const nb = this.cloneBoard(board);
    nb[r][c]=player;
    const opp = -player;
    let capturedStones = [];

    for(const [nr,nc] of this.neighbors4(r,c)){
      if(nb[nr][nc]!==opp) continue;
      const g = this.getGroup(nb, nr, nc);
      if(g.libs.size===0){
        capturedStones = capturedStones.concat(g.stones);
        this.removeStones(nb, g.stones);
      }
    }
    return { nb, capturedStones };
  }

  isLegalMove(r,c,player){
    if(!this.inBounds(r,c)) return {ok:false,msg:"è¶…å‡ºæ£‹ç›¤"};
    if(this.board[r][c]!==0) return {ok:false,msg:"æ­¤è™•å·²æœ‰å­"};

    const { nb } = this.applyMoveSim(this.board, r, c, player);

    const myGroup = this.getGroup(nb, r, c);
    if(myGroup.libs.size===0) return {ok:false,msg:"ç¦è‘—é»ï¼šè‡ªæ®ºï¼ˆç„¡æ°£ï¼‰"};

    const newHash = this.hashBoard(nb);
    if(newHash === this.prevBoardHash) return {ok:false,msg:"ç¦è‘—é»ï¼šåŠ«ï¼ˆéœ€å…ˆåœ¨åˆ¥è™•ä¸‹ä¸€æ‰‹ï¼‰"};

    return {ok:true, nb};
  }

  hasAnyLegalMove(player){
    for(let r=0;r<this.N;r++){
      for(let c=0;c<this.N;c++){
        if(this.board[r][c]!==0) continue;
        if(this.isLegalMove(r,c,player).ok) return true;
      }
    }
    return false;
  }

  // ---------- Atari (å«åƒ) detection ----------
  findAtariGroups(board, player){
    const seen = Array(this.N).fill(0).map(()=>Array(this.N).fill(false));
    const atari = [];
    for(let r=0;r<this.N;r++){
      for(let c=0;c<this.N;c++){
        if(board[r][c]!==player || seen[r][c]) continue;
        const g = this.getGroup(board, r, c);
        for(const [sr,sc] of g.stones) seen[sr][sc]=true;
        if(g.libs.size===1){
          atari.push(g.stones);
        }
      }
    }
    return atari;
  }

  updateAtariWarnings(lastPlayer){
    this.atariHighlights = [];
    const opp = -lastPlayer;

    const oppAtari = this.findAtariGroups(this.board, opp);
    const selfAtari = this.findAtariGroups(this.board, lastPlayer);

    for(const stones of oppAtari) this.atariHighlights.push({stones, kind:"opp"});
    for(const stones of selfAtari) this.atariHighlights.push({stones, kind:"self"});

    const nameOf = (p) => (p === 1 ? "é»‘æ–¹" : "ç™½æ–¹");

    let extra = "";
    if(oppAtari.length > 0){
      extra += `âš ï¸ å«åƒï¼${nameOf(opp)} æœ‰ ${oppAtari.length} å¡Šåªå‰© 1 æ°£ã€‚<br>`;
    }
    if(selfAtari.length > 0){
      extra += `âš ï¸ å°å¿ƒï¼${nameOf(lastPlayer)} æœ‰ ${selfAtari.length} å¡Šåªå‰© 1 æ°£ã€‚<br>`;
    }
    return extra;
  }

  // ---------- Play move ----------
  tryPlay(r,c,player){
    if(this.destroyed) return {ok:false,msg:"å·²é‡ç½®"};
    if(this.gameOver) return {ok:false,msg:"å·²çµ‚å±€"};
    const chk = this.isLegalMove(r,c,player);
    if(!chk.ok) return chk;

    const { capturedStones } = this.applyMoveSim(this.board, r, c, player);

    this.history.push({
      board: this.cloneBoard(this.board),
      currentPlayer: this.currentPlayer,
      consecutivePasses: this.consecutivePasses,
      prevBoardHash: this.prevBoardHash,
      lastMove: this.lastMove ? {...this.lastMove} : null,
      captures: { ...this.captures }
    });

    this.prevBoardHash = this.hashBoard(this.board);
    this.board = chk.nb;

    if(capturedStones.length > 0){
      if(player === 1) this.captures.black += capturedStones.length;
      else this.captures.white += capturedStones.length;

      const now = performance.now();
      for(const [rr,cc] of capturedStones){
        this.captureAnims.push({ r: rr, c: cc, player: -player, start: now, dur: 420 });
      }
    }

    this.lastMove = {r,c,player};
    this.consecutivePasses = 0;
    document.getElementById("passCount").textContent = "0";

    this.currentPlayer = -player;

    const extra = this.updateAtariWarnings(player);

    this.draw();
    this.updateScorePreview();
    this.updateStatus(extra);

    return {ok:true};
  }

  onCanvasClick(e){
    if(this.destroyed || this.gameOver) return;

    // ä½¿ç”¨è€…åªä¸‹é»‘æ£‹
    if(this.currentPlayer !== 1) return;

    const {r,c} = this.pickIntersection(e);
    if(r===null) return;

    const res = this.tryPlay(r,c,1);
    if(!res.ok){
      this.setStatus(`ğŸ–¤ é»‘æ£‹ï¼š${res.msg}`, "status no-move");
      this.setTimer(()=>this.updateStatus(), 650);
      return;
    }

    this.afterMove();
    if(this.aiEnabled && !this.gameOver && this.currentPlayer === -1){
      this.setTimer(()=>this.aiMove(), 220);
    }
  }

  afterMove(){
    if(this.destroyed || this.gameOver) return;

    const canMove = this.hasAnyLegalMove(this.currentPlayer);
    const oppCanMove = this.hasAnyLegalMove(-this.currentPlayer);

    if(!canMove && !oppCanMove){
      this.setStatus("é›™æ–¹éƒ½æ²’æœ‰åˆæ³•æ£‹æ­¥ â†’ è‡ªå‹•çµ‚å±€", "status no-move");
      this.setTimer(()=>this.endGame("âœ… é›™æ–¹å…¨ç¦è‘—é» / ç„¡åˆæ³•æ£‹æ­¥ï¼Œçµ‚å±€ï¼"), 700);
      return;
    }

    if(!canMove && oppCanMove){
      const who = this.currentPlayer===1 ? "ğŸ–¤ é»‘æ£‹" : "âšª ç™½æ£‹(AI)";
      this.setStatus(`${who} æ²’æœ‰åˆæ³•æ£‹æ­¥ â†’ è‡ªå‹•è™›æ‰‹`, "status no-move");
      this.setTimer(()=>this.pass(true), 650);
    }
  }

  pass(isAuto=false){
    if(this.destroyed || this.gameOver) return;

    this.history.push({
      board: this.cloneBoard(this.board),
      currentPlayer: this.currentPlayer,
      consecutivePasses: this.consecutivePasses,
      prevBoardHash: this.prevBoardHash,
      lastMove: this.lastMove ? {...this.lastMove} : null,
      captures: { ...this.captures }
    });

    this.consecutivePasses += 1;
    document.getElementById("passCount").textContent = String(this.consecutivePasses);

    if(this.consecutivePasses >= 2){
      this.endGame("âœ… é€£çºŒå…©æ¬¡è™›æ‰‹ï¼Œçµ‚å±€ï¼");
      return;
    }

    this.currentPlayer = -this.currentPlayer;

    this.atariHighlights = [];
    this.draw();
    this.updateScorePreview();
    this.updateStatus();

    this.afterMove();

    if(this.aiEnabled && !this.gameOver && this.currentPlayer === -1){
      this.setTimer(()=>this.aiMove(), isAuto ? 220 : 420);
    }
  }

  // ---------- AI ----------
  aiMove(){
    if(this.destroyed || this.gameOver || !this.aiEnabled || this.currentPlayer !== -1) return;

    if(!this.hasAnyLegalMove(-1)){
      this.pass(true);
      return;
    }

    const moves=[];
    for(let r=0;r<this.N;r++){
      for(let c=0;c<this.N;c++){
        if(this.board[r][c]!==0) continue;
        const chk = this.isLegalMove(r,c,-1);
        if(!chk.ok) continue;
        const score = this.evaluateAIMove(r,c,chk.nb);
        moves.push({r,c,score});
      }
    }
    moves.sort((a,b)=>b.score-a.score);
    const best = moves[0];
    this.tryPlay(best.r,best.c,-1);
    this.afterMove();
  }

  evaluateAIMove(r,c,simBoard){
    let s=0;

    const before = this.countStones(this.board);
    const after  = this.countStones(simBoard);
    const capturedBlack = before.black - after.black;
    if(capturedBlack>0) s += capturedBlack * 130;

    const g = this.getGroup(simBoard,r,c);
    s += Math.min(10, g.libs.size) * 6;

    const isStar = this.starPoints.some(p=>p.r===r && p.c===c);
    if(isStar) s += 16;
    const isCorner = (r===0||r===8) && (c===0||c===8);
    if(isCorner) s += 12;
    const isEdge = (r===0||r===8||c===0||c===8);
    if(isEdge) s += 4;

    for(const [nr,nc] of this.neighbors8(r,c)){
      if(this.board[nr][nc]===1) s += 4;
    }

    const selfAtari = this.findAtariGroups(simBoard, -1);
    if(selfAtari.length>0) s -= 18 * selfAtari.length;

    s += Math.random()*2;
    return s;
  }

  // ---------- Handicap ----------
  applyHandicapFromUI(){
    const h = parseInt(document.getElementById("handicapSel").value, 10);
    if(![0,2,3,4,5].includes(h)) return;

    this.board = this.makeEmpty();
    this.history = [];
    this.lastMove = null;
    this.consecutivePasses = 0;
    this.prevBoardHash = this.hashBoard(this.board);
    this.captures = { black: 0, white: 0 };

    document.getElementById("passCount").textContent = "0";

    const pts = this.handicapPoints(h);
    for(const p of pts) this.board[p.r][p.c] = 1;

    this.currentPlayer = (h===0) ? 1 : -1;
    this.prevBoardHash = this.hashBoard(this.board);

    this.atariHighlights = [];
    this.captureAnims = [];
  }

  handicapPoints(h){
    const a = {r:2,c:2}, b={r:2,c:6}, c={r:6,c:2}, d={r:6,c:6}, e={r:4,c:4};
    if(h===0) return [];
    if(h===2) return [a,d];
    if(h===3) return [a,b,d];
    if(h===4) return [a,b,c,d];
    if(h===5) return [a,b,c,d,e];
    return [];
  }

  // ---------- Overlay helpers ----------
  getEmptyRegions(board){
    const vis = Array(this.N).fill(0).map(()=>Array(this.N).fill(false));
    const regions = [];
    for(let r=0;r<this.N;r++){
      for(let c=0;c<this.N;c++){
        if(board[r][c]!==0 || vis[r][c]) continue;
        const stack=[[r,c]];
        vis[r][c]=true;
        const pts=[];
        const borderColors = new Set();
        while(stack.length){
          const [cr,cc]=stack.pop();
          pts.push([cr,cc]);
          for(const [nr,nc] of this.neighbors4(cr,cc)){
            if(board[nr][nc]===0 && !vis[nr][nc]){
              vis[nr][nc]=true; stack.push([nr,nc]);
            }else if(board[nr][nc]!==0){
              borderColors.add(board[nr][nc]);
            }
          }
        }
        regions.push({pts, borderColors});
      }
    }
    return regions;
  }

  removeDeadByBenson(board){
    let b = this.cloneBoard(board);
    const colors = [1,-1];

    for(const color of colors){
      let changed = true;
      while(changed){
        changed = false;

        const regions = this.getEmptyRegions(b);
        const eyeRegionIdx = new Set();
        regions.forEach((reg, idx)=>{
          if(reg.borderColors.size===1 && reg.borderColors.has(color)) eyeRegionIdx.add(idx);
        });

        const pointToRegion = new Map();
        regions.forEach((reg, idx)=>{
          for(const [r,c] of reg.pts) pointToRegion.set(r+"_"+c, idx);
        });

        const seen = Array(this.N).fill(0).map(()=>Array(this.N).fill(false));
        const blocks = [];

        for(let r=0;r<this.N;r++){
          for(let c=0;c<this.N;c++){
            if(b[r][c]!==color || seen[r][c]) continue;
            const g = this.getGroup(b, r, c);
            for(const [sr,sc] of g.stones) seen[sr][sc]=true;

            const adjEyes = new Set();
            for(const [sr,sc] of g.stones){
              for(const [nr,nc] of this.neighbors4(sr,sc)){
                if(b[nr][nc]===0){
                  const idx = pointToRegion.get(nr+"_"+nc);
                  if(idx!==undefined && eyeRegionIdx.has(idx)) adjEyes.add(idx);
                }
              }
            }
            blocks.push({stones:g.stones, eyes: adjEyes.size});
          }
        }

        for(const blk of blocks){
          if(blk.eyes < 2){
            this.removeStones(b, blk.stones);
            changed = true;
          }
        }
      }
    }
    return b;
  }

  computeOverlayData(){
    const cleaned = this.removeDeadByBenson(this.board);

    const dead = [];
    const alive = [];
    for(let r=0;r<this.N;r++){
      for(let c=0;c<this.N;c++){
        if(this.board[r][c]===0) continue;
        if(cleaned[r][c]===0) dead.push([r,c]);
        else alive.push([r,c]);
      }
    }

    const regions = this.getEmptyRegions(cleaned);
    const blackTerr = [];
    const whiteTerr = [];
    const neutral = [];
    for(const reg of regions){
      if(reg.borderColors.size===1){
        const only = [...reg.borderColors][0];
        if(only===1) blackTerr.push(...reg.pts);
        else if(only===-1) whiteTerr.push(...reg.pts);
        else neutral.push(...reg.pts);
      }else{
        neutral.push(...reg.pts);
      }
    }
    return { alive, dead, blackTerr, whiteTerr, neutral };
  }

  // ---------- Drawing ----------
  draw(){
    if(this.destroyed) return;
    const ctx = this.ctx;
    ctx.clearRect(0,0,this.canvas.width,this.canvas.height);

    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(30,20,10,0.85)";
    for(let i=0;i<this.N;i++){
      const x = this.padding + i*this.cell;
      const y = this.padding + i*this.cell;
      ctx.beginPath(); ctx.moveTo(this.padding, y); ctx.lineTo(this.canvas.width - this.padding, y); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x, this.padding); ctx.lineTo(x, this.canvas.height - this.padding); ctx.stroke();
    }

    for(const p of this.starPoints){
      const {x,y} = this.rcToXY(p.r,p.c);
      ctx.beginPath();
      ctx.fillStyle = "rgba(30,20,10,0.85)";
      ctx.arc(x,y,5.2,0,Math.PI*2);
      ctx.fill();
    }

    if(this.showOverlay){
      const ov = this.computeOverlayData();
      this.drawTerritoryOverlay(ov);
    }

    if(this.lastMove){
      const {x,y} = this.rcToXY(this.lastMove.r, this.lastMove.c);
      ctx.beginPath();
      ctx.strokeStyle = "rgba(255,215,0,0.95)";
      ctx.lineWidth = 3;
      ctx.arc(x,y, this.cell*0.22, 0, Math.PI*2);
      ctx.stroke();
    }

    for(let r=0;r<this.N;r++){
      for(let c=0;c<this.N;c++){
        const v = this.board[r][c];
        if(v===0) continue;
        this.drawStone(r,c,v);
      }
    }

    this.drawCaptureAnims();
    this.drawAtariHighlights();

    if(this.showOverlay){
      const ov = this.computeOverlayData();
      this.drawAliveDeadMarkers(ov);
    }
  }

  drawStone(r,c,player){
    const ctx = this.ctx;
    const {x,y} = this.rcToXY(r,c);
    const radius = this.cell*0.40;

    ctx.beginPath();
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.arc(x+2,y+3,radius,0,Math.PI*2);
    ctx.fill();

    const g = ctx.createRadialGradient(x-radius*0.25, y-radius*0.25, radius*0.2, x, y, radius);
    if(player===1){ g.addColorStop(0, "#3a3a3a"); g.addColorStop(1, "#050505"); }
    else{ g.addColorStop(0, "#ffffff"); g.addColorStop(1, "#cfcfcf"); }

    ctx.beginPath(); ctx.fillStyle = g; ctx.arc(x,y,radius,0,Math.PI*2); ctx.fill();
    ctx.beginPath();
    ctx.strokeStyle = player===1 ? "rgba(255,255,255,0.08)" : "rgba(0,0,0,0.10)";
    ctx.lineWidth = 2;
    ctx.arc(x,y,radius,0,Math.PI*2);
    ctx.stroke();
  }

  drawTerritoryOverlay(ov){
    const ctx = this.ctx;
    const drawDots = (pts, fillStyle) => {
      ctx.fillStyle = fillStyle;
      for(const [r,c] of pts){
        const {x,y} = this.rcToXY(r,c);
        ctx.beginPath();
        ctx.arc(x,y, this.cell*0.13, 0, Math.PI*2);
        ctx.fill();
      }
    };
    drawDots(ov.blackTerr, "rgba(0,0,0,0.22)");
    drawDots(ov.whiteTerr, "rgba(255,255,255,0.20)");
    drawDots(ov.neutral,   "rgba(241,196,15,0.12)");
  }

  drawAliveDeadMarkers(ov){
    const ctx = this.ctx;
    for(const [r,c] of ov.alive){
      const {x,y} = this.rcToXY(r,c);
      ctx.beginPath();
      ctx.strokeStyle = "rgba(46, 204, 113, 0.95)";
      ctx.lineWidth = 3;
      ctx.arc(x,y, this.cell*0.24, 0, Math.PI*2);
      ctx.stroke();
    }
    for(const [r,c] of ov.dead){
      const {x,y} = this.rcToXY(r,c);
      const s = this.cell*0.22;
      ctx.strokeStyle = "rgba(231, 76, 60, 0.95)";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(x-s, y-s); ctx.lineTo(x+s, y+s);
      ctx.moveTo(x+s, y-s); ctx.lineTo(x-s, y+s);
      ctx.stroke();
    }
  }

  drawAtariHighlights(){
    const ctx = this.ctx;
    if(!this.atariHighlights.length) return;

    for(const item of this.atariHighlights){
      const color = item.kind==="opp" ? "rgba(241,196,15,0.95)" : "rgba(230,126,34,0.95)";
      for(const [r,c] of item.stones){
        const {x,y} = this.rcToXY(r,c);
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.arc(x,y, this.cell*0.22, 0, Math.PI*2);
        ctx.stroke();
      }
    }
  }

  drawCaptureAnims(){
    const ctx = this.ctx;
    const now = performance.now();
    this.captureAnims = this.captureAnims.filter(a => now - a.start < a.dur);

    for(const a of this.captureAnims){
      const t = (now - a.start) / a.dur;
      const alpha = 1 - t;
      const shrink = 1 - 0.7*t;

      const {x,y} = this.rcToXY(a.r, a.c);
      const radius = this.cell*0.40 * shrink;

      ctx.save();
      ctx.globalAlpha = Math.max(0, alpha);
      const g = ctx.createRadialGradient(x-radius*0.25, y-radius*0.25, radius*0.2, x, y, radius);
      if(a.player===1){ g.addColorStop(0, "#3a3a3a"); g.addColorStop(1, "#050505"); }
      else{ g.addColorStop(0, "#ffffff"); g.addColorStop(1, "#cfcfcf"); }
      ctx.beginPath(); ctx.fillStyle = g; ctx.arc(x,y,radius,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }
  }

  startAnimLoop(){
    const loop = () => {
      if (this.destroyed) return;
      if(this.captureAnims.length > 0){
        this.draw();
      }
      this.rafId = requestAnimationFrame(loop);
    };
    this.rafId = requestAnimationFrame(loop);
  }

  // ---------- Status ----------
  updateStatus(extraHtml=""){
    if(this.destroyed || this.gameOver) return;

    const playerName = this.currentPlayer===1 ? "ğŸ–¤ é»‘æ£‹" : "âšª ç™½æ£‹(AI)";
    const canMove = this.hasAnyLegalMove(this.currentPlayer);

    if(canMove){
      this.setStatus(`${extraHtml}${playerName} å›åˆï¼šé»äº¤å‰é»ä¸‹å­ / æˆ–æŒ‰ã€Œè™›æ‰‹ã€`, "status");
    }else{
      this.setStatus(`${extraHtml}${playerName} æ²’æœ‰åˆæ³•æ£‹æ­¥ â†’ å°‡è‡ªå‹•è™›æ‰‹`, "status no-move");
    }
  }

  // ---------- Undo ----------
  undo(){
    if(this.destroyed || this.gameOver || this.history.length===0) return;
    const snap = this.history.pop();
    this.board = this.cloneBoard(snap.board);
    this.currentPlayer = snap.currentPlayer;
    this.consecutivePasses = snap.consecutivePasses;
    this.prevBoardHash = snap.prevBoardHash;
    this.lastMove = snap.lastMove;
    this.captures = { ...snap.captures };

    this.atariHighlights = [];
    this.captureAnims = [];

    document.getElementById("passCount").textContent = String(this.consecutivePasses);
    this.draw();
    this.updateScorePreview();
    this.updateStatus();
  }

  // ---------- Scoring (area) ----------
  countStones(board){
    let black=0, white=0;
    for(let r=0;r<this.N;r++){
      for(let c=0;c<this.N;c++){
        if(board[r][c]===1) black++;
        else if(board[r][c]===-1) white++;
      }
    }
    return {black, white};
  }

  scoreArea(board){
    const stones = this.countStones(board);
    let blackTerr=0, whiteTerr=0;

    const regions = this.getEmptyRegions(board);
    for(const reg of regions){
      if(reg.borderColors.size===1){
        const only = [...reg.borderColors][0];
        if(only===1) blackTerr += reg.pts.length;
        else if(only===-1) whiteTerr += reg.pts.length;
      }
    }

    const blackScore = stones.black + blackTerr;
    const whiteScore = stones.white + whiteTerr + this.komi;

    return {stones, terr:{blackTerr, whiteTerr}, score:{blackScore, whiteScore}};
  }

  updateScorePreview(){
    const res = this.scoreArea(this.board);

    document.getElementById("blackScore").textContent = res.score.blackScore.toFixed(2).replace(/\.00$/,"");
    document.getElementById("whiteScore").textContent = res.score.whiteScore.toFixed(2).replace(/\.00$/,"");
    document.getElementById("blackStones").textContent = res.stones.black;
    document.getElementById("whiteStones").textContent = res.stones.white;
    document.getElementById("blackTerr").textContent = res.terr.blackTerr;
    document.getElementById("whiteTerr").textContent = res.terr.whiteTerr;

    document.getElementById("blackCaps").textContent = this.captures.black;
    document.getElementById("whiteCaps").textContent = this.captures.white;
  }

  endGame(reason){
    if(this.destroyed) return;
    this.gameOver = true;
    document.getElementById("undoBtn").disabled = true;
    document.getElementById("passBtn").disabled = true;
    document.getElementById("handicapSel").disabled = true;

    const res = this.scoreArea(this.board);
    const b = res.score.blackScore;
    const w = res.score.whiteScore;
    const winner = (b>w) ? "ğŸ–¤ é»‘æ£‹å‹" : (w>b ? "âšª ç™½æ£‹å‹" : "å¹³æ‰‹");
    const margin = Math.abs(b-w).toFixed(2).replace(/\.00$/,"");

    this.draw();
    this.updateScorePreview();

    this.setStatus(
      `${reason}<br>${winner}<br>`+
      `æœ€çµ‚ï¼šé»‘ ${b.toFixed(2).replace(/\.00$/,"")}ï¼ˆå­${res.stones.black}+åœ°${res.terr.blackTerr}ï¼Œæå­${this.captures.black}ï¼‰`+
      ` : ç™½ ${w.toFixed(2).replace(/\.00$/,"")}ï¼ˆå­${res.stones.white}+åœ°${res.terr.whiteTerr}+è²¼ç›®${this.komi}ï¼Œæå­${this.captures.white}ï¼‰<br>`+
      `å­å·®ï¼š${margin}<br>`+
      `ï¼ˆå¯æŒ‰ã€Œæ´»æ£‹/åœ°ç›¤ é¡¯ç¤ºã€æª¢è¦–æ´»æ£‹/æ­»æ£‹/åœ°ç›¤ç¯„åœï¼‰`,
      "status game-over"
    );
  }
}

// globals
let game=null;

function newGame(){
  // âœ… å…ˆæ®ºæ‰ä¸Šä¸€å±€ï¼ˆåœæ‰ rAF + timeout + click listenerï¼‰
  if (game) game.destroy();

  document.getElementById("undoBtn").disabled = false;
  document.getElementById("passBtn").disabled = false;
  document.getElementById("handicapSel").disabled = false;

  game = new NineBoardGo();

  // âœ… è®“å­æ™‚ç™½å…ˆï¼šç›´æ¥è®“ AI å…ˆä¸‹ï¼ˆç”¨ setTimer ä¹Ÿèƒ½è¢« destroy æ¸…æ‰ï¼‰
  if(!game.gameOver && game.currentPlayer === -1){
    game.setTimer(()=>game.aiMove(), 200);
  }
}

window.onload = ()=>newGame();
</script>
</body>
</html>
