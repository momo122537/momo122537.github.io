<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>1122915-FinalTerm</title>
  <style>
    body{
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg,#2c3e50,#34495e);
      display:flex; justify-content:center; align-items:center;
      min-height:100vh; margin:0; color:#ecf0f1;
    }
    .game-container{
      text-align:center;
      background: rgba(0,0,0,0.82);
      padding: 26px;
      border-radius: 20px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
      width:min(92vw, 760px);
    }
    h1{
      font-size:2.2em;
      background: linear-gradient(45deg,#f39c12,#e67e22);
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      margin: 10px 0 6px;
    }
    .status{
      font-size:1.05em;
      margin: 14px 0;
      padding: 12px 14px;
      background: rgba(52,73,94,0.75);
      border-radius: 12px;
      border: 2px solid #3498db;
      line-height: 1.55;
    }
    .board-wrap{ display:flex; justify-content:center; margin: 16px auto 10px; }
    canvas{
      background: radial-gradient(circle at 40% 35%, #a8733a 0%, #7a4b21 60%, #5b3618 100%);
      border-radius: 16px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.5);
      touch-action: none;
    }
    .controls{ margin-top: 10px; display:flex; flex-wrap:wrap; gap:8px; justify-content:center; align-items:center; }
    button, select{
      border:none;
      padding: 11px 16px;
      border-radius: 999px;
      font-size: 15px;
    }
    button{
      background: linear-gradient(45deg,#3498db,#2980b9);
      color:#fff; cursor:pointer;
      transition: all .25s ease;
    }
    button:hover:not(:disabled){
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(52,152,219,0.55);
    }
    button:disabled{ background:#95a5a6; cursor:not-allowed; }
    .pass-btn{
      background: linear-gradient(45deg,#f39c12,#e67e22) !important;
      font-weight: 700;
    }
    .pass-btn:hover:not(:disabled){
      box-shadow: 0 8px 25px rgba(243,156,18,0.55) !important;
    }
    select{
      background: rgba(255,255,255,0.14);
      color:#ecf0f1;
      border: 2px solid rgba(255,255,255,0.25);
      outline:none;
    }
    option{ color:#111; }
    .score{
      display:flex;
      justify-content:space-around;
      margin-top: 12px;
      font-size: 1.12em;
      font-weight: 700;
      gap: 10px;
      flex-wrap: wrap;
    }
    .score div{
      padding: 10px 16px;
      border-radius: 12px;
      min-width: 260px;
    }
    .black-score{ background: rgba(0,0,0,0.65); border: 2px solid #333; }
    .white-score{ background: rgba(255,255,255,0.16); border: 2px solid rgba(255,255,255,0.45); }
    #passInfo{
      font-size: 0.98em; color:#f1c40f; font-weight:700;
      margin-top: 10px; padding: 8px 10px;
      background: rgba(0,0,0,0.45);
      border-radius: 12px;
      display:inline-block;
    }
    .game-over{
      background: rgba(231,76,60,0.92) !important;
      border-color:#c0392b !important;
      animation: flash 1s infinite;
      font-size: 1.08em;
    }
    @keyframes flash{ 0%,100%{opacity:1;} 50%{opacity:.72;} }
    .no-move{
      background: rgba(243,156,18,0.75) !important;
      border-color:#f39c12 !important;
    }
    .mini{ opacity:0.92; font-size:0.92em; font-weight:600; margin-top:6px; }
  </style>
</head>
<body>
  <div class="game-container">
    <h1>ğŸ¯ ä¹è·¯åœæ£‹</h1>
    <div class="status" id="status">ğŸ–¤ é»‘æ£‹å…ˆæ‰‹ï¼šé»äº¤å‰é»ä¸‹å­</div>

    <div class="board-wrap">
      <canvas id="goboard" width="560" height="560" aria-label="9x9 go board"></canvas>
    </div>

    <div class="controls">
      <select id="handicapSel" title="è®“å­æ•¸ï¼ˆå…ˆæ“ºé»‘å­ï¼Œç™½å…ˆï¼‰">
        <option value="0" selected>è®“å­ï¼š0ï¼ˆåˆ†å…ˆï¼‰</option>
        <option value="2">è®“å­ï¼š2ï¼ˆç™½å…ˆï¼‰</option>
        <option value="3">è®“å­ï¼š3ï¼ˆç™½å…ˆï¼‰</option>
        <option value="4">è®“å­ï¼š4ï¼ˆç™½å…ˆï¼‰</option>
        <option value="5">è®“å­ï¼š5ï¼ˆç™½å…ˆï¼‰</option>
      </select>

      <button id="undoBtn">æ‚”æ£‹</button>
      <button id="newBtn">æ–°å±€</button>
      <button class="pass-btn" id="passBtn">è™›æ‰‹(åœä¸€æ‰‹)</button>
      <button id="aiBtn">AIé–‹é—œ (é–‹)</button>
    </div>

    <div class="score">
      <div class="black-score">
        é»‘ï¼ˆæ•¸å­æ³•ï¼‰: <span id="blackScore">0</span>
        <div class="mini">æ£‹å­ï¼š<span id="blackStones">0</span>ï½œåœ°ï¼š<span id="blackTerr">0</span></div>
      </div>
      <div class="white-score">
        ç™½ï¼ˆæ•¸å­æ³• + è²¼ç›®3.75ï¼‰: <span id="whiteScore">0</span>
        <div class="mini">æ£‹å­ï¼š<span id="whiteStones">0</span>ï½œåœ°ï¼š<span id="whiteTerr">0</span>ï½œè²¼ç›®ï¼š<span id="komi">3.75</span></div>
      </div>
    </div>

    <div id="passInfo">é€£çºŒè™›æ‰‹: <span id="passCount">0</span>/2</div>
  </div>

<script>
class NineBoardGo {
  constructor(){
    this.N = 9;
    this.board = this.makeEmpty();
    this.currentPlayer = 1; // 1 black(user), -1 white(AI)
    this.consecutivePasses = 0;
    this.aiEnabled = true;
    this.gameOver = false;

    // è¦å‰‡é æåˆ°è²¼ç›® 3åˆ3/4 å­ï¼ˆ3.75ï¼‰:contentReference[oaicite:9]{index=9}
    this.komi = 3.75;

    // ç”¨æ–¼ã€ŒåŠ«è¦éš”ä¸€æ‰‹ã€ï¼šç¦æ­¢å›åˆ°ä¸Šä¸€æ‰‹å±€é¢ï¼ˆç°¡å–®KOï¼‰:contentReference[oaicite:10]{index=10}
    this.prevBoardHash = this.hashBoard(this.board);

    this.history = [];
    this.lastMove = null;

    this.canvas = document.getElementById("goboard");
    this.ctx = this.canvas.getContext("2d");
    this.padding = 46;
    this.cell = (this.canvas.width - this.padding*2) / (this.N - 1);

    // 9è·¯å¸¸ç”¨æ˜Ÿä½ï¼ˆå››è§’æ˜Ÿ + å¤©å…ƒï¼‰
    this.starPoints = [{r:2,c:2},{r:2,c:6},{r:6,c:2},{r:6,c:6},{r:4,c:4}];

    this.bindUI();
    this.applyHandicapFromUI(); // è®“å­æ£‹ï¼šå…ˆæ“ºé»‘å­ï¼Œç™½å…ˆ :contentReference[oaicite:11]{index=11}
    this.draw();
    this.updateStatus();
    this.updateScorePreview();
  }

  makeEmpty(){ return Array(this.N).fill(0).map(()=>Array(this.N).fill(0)); }
  cloneBoard(b){ return b.map(row=>row.slice()); }
  inBounds(r,c){ return r>=0 && r<this.N && c>=0 && c<this.N; }
  neighbors4(r,c){ return [[r-1,c],[r+1,c],[r,c-1],[r,c+1]].filter(([rr,cc])=>this.inBounds(rr,cc)); }
  neighbors8(r,c){
    const ds=[-1,0,1], out=[];
    for(const dr of ds) for(const dc of ds){
      if(dr===0 && dc===0) continue;
      out.push([r+dr,c+dc]);
    }
    return out;
  }

  bindUI(){
    this.canvas.addEventListener("click", (e)=>this.onCanvasClick(e));
    document.getElementById("undoBtn").onclick = ()=>this.undo();
    document.getElementById("newBtn").onclick = ()=>newGame();
    document.getElementById("passBtn").onclick = ()=>this.pass();
    document.getElementById("aiBtn").onclick = ()=>toggleAI();
    document.getElementById("handicapSel").onchange = ()=> newGame();
    document.getElementById("komi").textContent = String(this.komi);
  }

  setStatus(html, cls="status"){
    const el = document.getElementById("status");
    el.className = cls;
    el.innerHTML = html;
  }

  pickIntersection(e){
    const rect = this.canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    const rFloat = (y - this.padding) / this.cell;
    const cFloat = (x - this.padding) / this.cell;

    const r = Math.round(rFloat);
    const c = Math.round(cFloat);
    if(r < 0 || r >= this.N || c < 0 || c >= this.N) return {r:null,c:null};

    const ix = this.padding + c*this.cell;
    const iy = this.padding + r*this.cell;
    const dist = Math.hypot(ix-x, iy-y);
    if(dist > this.cell*0.42) return {r:null,c:null};

    return {r,c};
  }

  rcToXY(r,c){ return { x: this.padding + c*this.cell, y: this.padding + r*this.cell }; }

  draw(){
    const ctx = this.ctx;
    ctx.clearRect(0,0,this.canvas.width,this.canvas.height);

    // æ ¼ç·šï¼ˆæ£‹å­ä¸‹åœ¨äº¤å‰é»ï¼‰:contentReference[oaicite:12]{index=12}
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(30,20,10,0.85)";
    for(let i=0;i<this.N;i++){
      const x = this.padding + i*this.cell;
      const y = this.padding + i*this.cell;

      ctx.beginPath(); ctx.moveTo(this.padding, y); ctx.lineTo(this.canvas.width - this.padding, y); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x, this.padding); ctx.lineTo(x, this.canvas.height - this.padding); ctx.stroke();
    }

    // æ˜Ÿä½ï¼ˆè­˜åˆ¥ä½ç½®ç”¨ï¼‰
    for(const p of this.starPoints){
      const {x,y} = this.rcToXY(p.r,p.c);
      ctx.beginPath();
      ctx.fillStyle = "rgba(30,20,10,0.85)";
      ctx.arc(x,y,5.2,0,Math.PI*2);
      ctx.fill();
    }

    // ä¸Šä¸€æ­¥æç¤ºåœˆ
    if(this.lastMove){
      const {x,y} = this.rcToXY(this.lastMove.r, this.lastMove.c);
      ctx.beginPath();
      ctx.strokeStyle = "rgba(255,215,0,0.95)";
      ctx.lineWidth = 3;
      ctx.arc(x,y, this.cell*0.22, 0, Math.PI*2);
      ctx.stroke();
    }

    // ç•«æ£‹å­
    for(let r=0;r<this.N;r++){
      for(let c=0;c<this.N;c++){
        const v = this.board[r][c];
        if(v===0) continue;
        this.drawStone(r,c,v);
      }
    }
  }

  drawStone(r,c,player){
    const ctx = this.ctx;
    const {x,y} = this.rcToXY(r,c);
    const radius = this.cell*0.40;

    ctx.beginPath();
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.arc(x+2,y+3,radius,0,Math.PI*2);
    ctx.fill();

    const g = ctx.createRadialGradient(x-radius*0.25, y-radius*0.25, radius*0.2, x, y, radius);
    if(player===1){ g.addColorStop(0, "#3a3a3a"); g.addColorStop(1, "#050505"); }
    else{ g.addColorStop(0, "#ffffff"); g.addColorStop(1, "#cfcfcf"); }

    ctx.beginPath(); ctx.fillStyle = g; ctx.arc(x,y,radius,0,Math.PI*2); ctx.fill();

    ctx.beginPath();
    ctx.strokeStyle = player===1 ? "rgba(255,255,255,0.08)" : "rgba(0,0,0,0.10)";
    ctx.lineWidth = 2;
    ctx.arc(x,y,radius,0,Math.PI*2);
    ctx.stroke();
  }

  hashBoard(b){ return b.map(row=>row.join(",")).join(";"); }

  getGroup(board, r, c){
    const color = board[r][c];
    if(color===0) return {stones:[], libs:new Set()};
    const stack = [[r,c]];
    const seen = Array(this.N).fill(0).map(()=>Array(this.N).fill(false));
    const stones = [];
    const libs = new Set();

    seen[r][c]=true;
    while(stack.length){
      const [cr,cc] = stack.pop();
      stones.push([cr,cc]);
      for(const [nr,nc] of this.neighbors4(cr,cc)){
        if(board[nr][nc]===0) libs.add(nr+"_"+nc);
        else if(board[nr][nc]===color && !seen[nr][nc]){
          seen[nr][nc]=true; stack.push([nr,nc]);
        }
      }
    }
    return {stones, libs};
  }

  removeStones(board, stones){
    for(const [r,c] of stones) board[r][c]=0;
  }

  applyMoveSim(board, r, c, player){
    const nb = this.cloneBoard(board);
    nb[r][c]=player;
    const opp = -player;

    // è¦å‰‡äº”ï¼šç„¡æ°£æ£‹å­ä¸èƒ½å­˜åœ¨ -> è½å­å¾Œææ‰å°æ–¹ç„¡æ°£æ£‹å¡Š :contentReference[oaicite:13]{index=13}
    for(const [nr,nc] of this.neighbors4(r,c)){
      if(nb[nr][nc]!==opp) continue;
      const g = this.getGroup(nb, nr, nc);
      if(g.libs.size===0) this.removeStones(nb, g.stones);
    }
    return nb;
  }

  isLegalMove(r,c,player){
    if(!this.inBounds(r,c)) return {ok:false,msg:"è¶…å‡ºæ£‹ç›¤"};
    if(this.board[r][c]!==0) return {ok:false,msg:"æ­¤è™•å·²æœ‰å­"};

    const nb = this.applyMoveSim(this.board, r, c, player);

    // è¦å‰‡å…­ï¼šæ²’æœ‰æ°£çš„äº¤å‰é»ä¸èƒ½ä¸‹ï¼ˆè‡ªæ®ºç¦è‘—ï¼Œé™¤éæå­å¾Œæœ‰æ°£ï¼‰:contentReference[oaicite:14]{index=14}
    const myGroup = this.getGroup(nb, r, c);
    if(myGroup.libs.size===0) return {ok:false,msg:"ç¦è‘—é»ï¼šè‡ªæ®ºï¼ˆç„¡æ°£ï¼‰"};

    // è¦å‰‡ä¸ƒï¼šåŠ«è¦éš”ä¸€æ‰‹ï¼ˆç°¡å–®KOï¼šä¸å¾—ç«‹åˆ»å›åˆ°ä¸Šä¸€å±€é¢ï¼‰:contentReference[oaicite:15]{index=15}
    const newHash = this.hashBoard(nb);
    if(newHash === this.prevBoardHash) return {ok:false,msg:"ç¦è‘—é»ï¼šåŠ«ï¼ˆéœ€å…ˆåœ¨åˆ¥è™•ä¸‹ä¸€æ‰‹ï¼‰"};

    return {ok:true, nb};
  }

  hasAnyLegalMove(player){
    for(let r=0;r<this.N;r++){
      for(let c=0;c<this.N;c++){
        if(this.board[r][c]!==0) continue;
        if(this.isLegalMove(r,c,player).ok) return true;
      }
    }
    return false;
  }

  tryPlay(r,c,player){
    if(this.gameOver) return {ok:false,msg:"å·²çµ‚å±€"};
    const chk = this.isLegalMove(r,c,player);
    if(!chk.ok) return chk;

    // snapshot for undo
    this.history.push({
      board: this.cloneBoard(this.board),
      currentPlayer: this.currentPlayer,
      consecutivePasses: this.consecutivePasses,
      prevBoardHash: this.prevBoardHash,
      lastMove: this.lastMove ? {...this.lastMove} : null
    });

    // apply + update ko reference to "previous position"
    this.prevBoardHash = this.hashBoard(this.board);
    this.board = chk.nb;

    this.lastMove = {r,c,player};
    this.consecutivePasses = 0;
    document.getElementById("passCount").textContent = "0";

    this.currentPlayer = -player;

    this.draw();
    this.updateScorePreview();
    this.updateStatus();
    return {ok:true};
  }

  onCanvasClick(e){
    if(this.gameOver) return;

    // ä½¿ç”¨è€…æ°¸é é»‘å…ˆï¼ˆé™¤éè®“å­æ£‹ï¼Œæœƒè®Šæˆç™½å…ˆï¼‰:contentReference[oaicite:16]{index=16}
    if(this.currentPlayer !== 1) return;

    const {r,c} = this.pickIntersection(e);
    if(r===null) return;

    const res = this.tryPlay(r,c,1);
    if(!res.ok){
      this.setStatus(`ğŸ–¤ é»‘æ£‹ï¼š${res.msg}`, "status no-move");
      setTimeout(()=>this.updateStatus(), 650);
      return;
    }

    this.afterMove();
    if(this.aiEnabled && !this.gameOver && this.currentPlayer === -1){
      setTimeout(()=>this.aiMove(), 220);
    }
  }

  afterMove(){
    if(this.gameOver) return;

    const canMove = this.hasAnyLegalMove(this.currentPlayer);
    const oppCanMove = this.hasAnyLegalMove(-this.currentPlayer);

    if(!canMove && !oppCanMove){
      this.setStatus("é›™æ–¹éƒ½æ²’æœ‰åˆæ³•æ£‹æ­¥ â†’ è‡ªå‹•çµ‚å±€", "status no-move");
      setTimeout(()=>this.endGame("âœ… é›™æ–¹å…¨ç¦è‘—é» / ç„¡åˆæ³•æ£‹æ­¥ï¼Œçµ‚å±€ï¼"), 700);
      return;
    }

    if(!canMove && oppCanMove){
      const who = this.currentPlayer===1 ? "ğŸ–¤ é»‘æ£‹" : "âšª ç™½æ£‹(AI)";
      this.setStatus(`${who} æ²’æœ‰åˆæ³•æ£‹æ­¥ â†’ è‡ªå‹•è™›æ‰‹`, "status no-move");
      setTimeout(()=>this.pass(true), 650);
    }
  }

  pass(isAuto=false){
    if(this.gameOver) return;

    // snapshot for undo
    this.history.push({
      board: this.cloneBoard(this.board),
      currentPlayer: this.currentPlayer,
      consecutivePasses: this.consecutivePasses,
      prevBoardHash: this.prevBoardHash,
      lastMove: this.lastMove ? {...this.lastMove} : null
    });

    this.consecutivePasses += 1;
    document.getElementById("passCount").textContent = String(this.consecutivePasses);

    if(this.consecutivePasses >= 2){
      this.endGame("âœ… é€£çºŒå…©æ¬¡è™›æ‰‹ï¼Œçµ‚å±€ï¼");
      return;
    }

    this.currentPlayer = -this.currentPlayer;
    this.updateStatus();
    this.afterMove();

    if(this.aiEnabled && !this.gameOver && this.currentPlayer === -1){
      setTimeout(()=>this.aiMove(), isAuto ? 220 : 420);
    }
  }

  aiMove(){
    if(this.gameOver || !this.aiEnabled || this.currentPlayer !== -1) return;
    if(!this.hasAnyLegalMove(-1)){
      this.pass(true);
      return;
    }

    const moves=[];
    for(let r=0;r<this.N;r++){
      for(let c=0;c<this.N;c++){
        if(this.board[r][c]!==0) continue;
        const chk = this.isLegalMove(r,c,-1);
        if(!chk.ok) continue;
        const score = this.evaluateAIMove(r,c,chk.nb);
        moves.push({r,c,score});
      }
    }
    moves.sort((a,b)=>b.score-a.score);
    const best = moves[0];
    this.tryPlay(best.r,best.c,-1);
    this.afterMove();
  }

  evaluateAIMove(r,c,simBoard){
    // 1) å„ªå…ˆæå­ 2) ä¿æŒæ°£ 3) æ˜Ÿä½/è§’ 4) é è¿‘é»‘å­
    let s=0;

    // capture estimate by stone count delta
    const before = this.countStones(this.board);
    const after  = this.countStones(simBoard);
    const capturedBlack = before.black - after.black;
    if(capturedBlack>0) s += capturedBlack * 120;

    const g = this.getGroup(simBoard,r,c);
    s += Math.min(10, g.libs.size) * 6;

    // favor star/corner/edge
    const isStar = this.starPoints.some(p=>p.r===r && p.c===c);
    if(isStar) s += 18;
    const isCorner = (r===0||r===8) && (c===0||c===8);
    if(isCorner) s += 12;
    const isEdge = (r===0||r===8||c===0||c===8);
    if(isEdge) s += 5;

    for(const [nr,nc] of this.neighbors8(r,c)){
      if(this.inBounds(nr,nc) && this.board[nr][nc]===1) s += 4;
    }

    s += Math.random()*2;
    return s;
  }

  updateStatus(){
    if(this.gameOver) return;

    const playerName = this.currentPlayer===1 ? "ğŸ–¤ é»‘æ£‹" : "âšª ç™½æ£‹(AI)";
    const canMove = this.hasAnyLegalMove(this.currentPlayer);

    if(canMove){
      this.setStatus(`${playerName} å›åˆï¼šé»äº¤å‰é»ä¸‹å­ / æˆ–æŒ‰ã€Œè™›æ‰‹ã€`, "status");
    }else{
      this.setStatus(`${playerName} æ²’æœ‰åˆæ³•æ£‹æ­¥ â†’ å°‡è‡ªå‹•è™›æ‰‹`, "status no-move");
    }
  }

  undo(){
    if(this.gameOver || this.history.length===0) return;
    const snap = this.history.pop();
    this.board = this.cloneBoard(snap.board);
    this.currentPlayer = snap.currentPlayer;
    this.consecutivePasses = snap.consecutivePasses;
    this.prevBoardHash = snap.prevBoardHash;
    this.lastMove = snap.lastMove;

    document.getElementById("passCount").textContent = String(this.consecutivePasses);
    this.draw();
    this.updateScorePreview();
    this.updateStatus();
  }

  // scoring (æ•¸å­æ³• / area): stones + surrounded empty territory
  countStones(board){
    let black=0, white=0;
    for(let r=0;r<this.N;r++){
      for(let c=0;c<this.N;c++){
        if(board[r][c]===1) black++;
        else if(board[r][c]===-1) white++;
      }
    }
    return {black, white};
  }

  getEmptyRegions(board){
    const vis = Array(this.N).fill(0).map(()=>Array(this.N).fill(false));
    const regions = [];
    for(let r=0;r<this.N;r++){
      for(let c=0;c<this.N;c++){
        if(board[r][c]!==0 || vis[r][c]) continue;
        const stack=[[r,c]];
        vis[r][c]=true;
        const pts=[];
        const borderColors = new Set();
        while(stack.length){
          const [cr,cc]=stack.pop();
          pts.push([cr,cc]);
          for(const [nr,nc] of this.neighbors4(cr,cc)){
            if(board[nr][nc]===0 && !vis[nr][nc]){
              vis[nr][nc]=true; stack.push([nr,nc]);
            }else if(board[nr][nc]!==0){
              borderColors.add(board[nr][nc]);
            }
          }
        }
        regions.push({pts, borderColors});
      }
    }
    return regions;
  }

  scoreArea(board){
    const stones = this.countStones(board);
    let blackTerr=0, whiteTerr=0;

    const regions = this.getEmptyRegions(board);
    for(const reg of regions){
      if(reg.borderColors.size===1){
        const only = [...reg.borderColors][0];
        if(only===1) blackTerr += reg.pts.length;
        else if(only===-1) whiteTerr += reg.pts.length;
      }
      // else neutral
    }

    const blackScore = stones.black + blackTerr;
    const whiteScore = stones.white + whiteTerr + this.komi; // è²¼ç›® :contentReference[oaicite:17]{index=17}

    return {stones, terr:{blackTerr, whiteTerr}, score:{blackScore, whiteScore}};
  }

  updateScorePreview(){
    // éŠæˆ²ä¸­ä¹Ÿå¯ç›´æ¥é è¦½ï¼ˆå’Œçµ‚å±€åŒç®—æ³•ï¼Œæ–¹ä¾¿é©—æ”¶ï¼‰
    const res = this.scoreArea(this.board);
    document.getElementById("blackScore").textContent = res.score.blackScore.toFixed(2).replace(/\.00$/,"");
    document.getElementById("whiteScore").textContent = res.score.whiteScore.toFixed(2).replace(/\.00$/,"");
    document.getElementById("blackStones").textContent = res.stones.black;
    document.getElementById("whiteStones").textContent = res.stones.white;
    document.getElementById("blackTerr").textContent = res.terr.blackTerr;
    document.getElementById("whiteTerr").textContent = res.terr.whiteTerr;
  }

  endGame(reason){
    this.gameOver = true;
    document.getElementById("undoBtn").disabled = true;
    document.getElementById("passBtn").disabled = true;
    document.getElementById("handicapSel").disabled = true;

    const res = this.scoreArea(this.board);
    const b = res.score.blackScore;
    const w = res.score.whiteScore;
    const winner = (b>w) ? "ğŸ–¤ é»‘æ£‹å‹" : (w>b ? "âšª ç™½æ£‹å‹" : "å¹³æ‰‹");
    const margin = Math.abs(b-w).toFixed(2).replace(/\.00$/,"");

    this.draw();
    this.updateScorePreview();

    this.setStatus(
      `${reason}<br>${winner}<br>`+
      `æœ€çµ‚ï¼šé»‘ ${b.toFixed(2).replace(/\.00$/,"")}ï¼ˆå­${res.stones.black}+åœ°${res.terr.blackTerr}ï¼‰`+
      ` : ç™½ ${w.toFixed(2).replace(/\.00$/,"")}ï¼ˆå­${res.stones.white}+åœ°${res.terr.whiteTerr}+è²¼ç›®${this.komi}ï¼‰<br>`+
      `å­å·®ï¼š${margin}`,
      "status game-over"
    );
  }

  // Handicap: place black stones before start; white plays first :contentReference[oaicite:18]{index=18}
  applyHandicapFromUI(){
    const h = parseInt(document.getElementById("handicapSel").value, 10);
    if(![0,2,3,4,5].includes(h)) return;

    // reset
    this.board = this.makeEmpty();
    this.history = [];
    this.lastMove = null;
    this.consecutivePasses = 0;
    document.getElementById("passCount").textContent = "0";

    const pts = this.handicapPoints(h);
    for(const p of pts){
      this.board[p.r][p.c] = 1;
    }

    // è®“å­æ£‹ç™½å…ˆï¼›åˆ†å…ˆé»‘å…ˆ :contentReference[oaicite:19]{index=19}
    this.currentPlayer = (h===0) ? 1 : -1;

    this.prevBoardHash = this.hashBoard(this.board);
    document.getElementById("handicapSel").disabled = false;
  }

  handicapPoints(h){
    // 9è·¯æœ€å¤šåˆç†åˆ° 5ï¼ˆå››è§’æ˜Ÿ + å¤©å…ƒï¼‰
    const a = {r:2,c:2}, b={r:2,c:6}, c={r:6,c:2}, d={r:6,c:6}, e={r:4,c:4};
    if(h===0) return [];
    if(h===2) return [a,d];
    if(h===3) return [a,b,d];
    if(h===4) return [a,b,c,d];
    if(h===5) return [a,b,c,d,e];
    return [];
  }
}

// globals
let game=null;

function newGame(){
  document.getElementById("undoBtn").disabled = false;
  document.getElementById("passBtn").disabled = false;
  document.getElementById("handicapSel").disabled = false;

  game = new NineBoardGo();

  // å¦‚æœæ˜¯è®“å­æ£‹ï¼ˆç™½å…ˆï¼‰ä¸”AIé–‹ï¼Œç›´æ¥è®“AIèµ°
  if(game.aiEnabled && !game.gameOver && game.currentPlayer === -1){
    setTimeout(()=>game.aiMove(), 200);
  }
}

function toggleAI(){
  if(!game) return;
  game.aiEnabled = !game.aiEnabled;
  document.getElementById("aiBtn").textContent = game.aiEnabled ? "AIé–‹é—œ (é–‹)" : "AIé–‹é—œ (é—œ)";
  if(game.aiEnabled && !game.gameOver && game.currentPlayer === -1){
    setTimeout(()=>game.aiMove(), 200);
  }
}

window.onload = ()=>newGame();
</script>
</body>
</html>
